=====================================================================
                        DISJOINT SET UNION (DSU)
                         UNION FIND DATA STRUCTURE
=====================================================================

ğŸ“Œ DEFINITION:
- Disjoint Set Union (DSU) or Union-Find is a data structure that keeps track of 
  elements divided into multiple disjoint (non-overlapping) sets.

- It efficiently supports two operations:
    1. FIND(x): Determines the ultimate parent (representative) of element x.
    2. UNION(x, y): Merges the sets containing elements x and y.

=====================================================================
ğŸ“Œ WHY USE DSU?
- Efficient way to handle dynamic connectivity.
- Used in solving:
    âœ… Cycle Detection in Graphs
    âœ… Kruskalâ€™s Minimum Spanning Tree Algorithm
    âœ… Connected Components in Graphs
    âœ… Grouping and Partitioning Problems
    âœ… Network Connectivity Problems

=====================================================================
ğŸ“Œ KEY OPERATIONS:
1. FIND(x) - Path Compression
   â†’ Purpose: Find the ultimate parent of x.
   â†’ Optimization: Path compression flattens the tree to speed up future queries.

2. UNION(x, y) - Union by Rank / Union by Size
   â†’ Purpose: Merge two disjoint sets.
   â†’ Optimization: Attach the smaller tree under the larger tree to keep trees shallow.

=====================================================================
ğŸ“Œ PATH COMPRESSION (in FIND)
- When we find the parent of a node, we update its parent directly to the root.
- Flattens the tree structure.
- Makes future find operations extremely fast.

Example:
find(x)
{
    if (par[x] == x)
        return x;
    return par[x] = find(par[x]);  // Path compression
}

=====================================================================
ğŸ“Œ UNION BY RANK
- Rank represents the approximate height of the tree.
- Always attach the smaller ranked tree under the higher ranked tree.

Steps:
- If rank[x] == rank[y], attach y under x and increase rank[x] by 1.
- If rank[x] > rank[y], attach y under x.
- If rank[x] < rank[y], attach x under y.

=====================================================================
ğŸ“Œ TIME COMPLEXITY:
- Using path compression and union by rank â†’ O(Î±(N))
- Î±(N) is the inverse Ackermann function â†’ practically constant time.

Efficient for VERY large data sets.

=====================================================================
ğŸ“Œ VS CODE QUICK RECAP:

ğŸ‘‰ FIND(x): O(Î±(N))
ğŸ‘‰ UNION(x, y): O(Î±(N))
ğŸ‘‰ Use PATH COMPRESSION in FIND
ğŸ‘‰ Use UNION BY RANK to balance sets
ğŸ‘‰ Almost constant time per operation

=====================================================================
ğŸ“Œ APPLICATIONS:
- Kruskalâ€™s Algorithm for Minimum Spanning Tree (MST)
- Detecting Cycles in Undirected Graphs
- Network Connectivity Problems
- Dynamic Graph Connectivity
- Connected Components Counting

=====================================================================
ğŸ“Œ COMMON INTERVIEW PROBLEMS:
1. Number of Connected Components in a Graph
2. Detect Cycle in an Undirected Graph
3. Accounts Merge (LeetCode)
4. Redundant Connection (LeetCode)
5. Similar String Groups

=====================================================================
ğŸ“Œ FINAL TIPS:
âœ… Always use path compression in FIND.
âœ… Always use union by rank or size for optimal merging.
âœ… Revise Kruskalâ€™s Algorithm with DSU for MST.
âœ… Practice LeetCode DSU tag problems.

=====================================================================
